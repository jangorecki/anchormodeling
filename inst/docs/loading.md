# Design notes FOR am$load method:

- [ ] loading model unit tests:
  - [ ] one flat data
  - [ ] two flat data
  - [ ] multiple flat data
- [ ] ETL template:
  - [x] isolate IM - loading anchors
    - [x] lookup anchor PK from local IM table to incoming data
    - [x] generate new PK for new rows
    - [x] write new rows to IM
    - [x] include just im$use()
  - [ ] isolate single anchor loading: model processing of single anchor load as atomic operation
    - [ ] NO calls like `self$data <- rbindlist(...)`
    - [ ] as easy as lapply
    - [ ] make it parallal
- [ ] loading process, two pass: detailed validation then loading
  - [ ] AM$load
    - [x] unique names `length(names(data))==uniqueN(names(data))`
    - [x] model-mapping validation
      - [x] multiple *exists*/*valid* checks
        - [x] any nested element with `"" / NULL / hist` name must exists in incoming data
    - [x] surrogate key gen function based on nk
    - [x] check NK (provide by anchor and *src cols*)
      - [x] exists in incoming data
      - [x] exists in currently using mapping
    - [x] prepare sequence of loading
      - [x] knots - parallel
      - [x] anchors - parallel
        - [x] attributes
      - [ ] ties
    - [ ] child classes related validation
    - [ ] call $load.AMobj just with a subset of cols
    - [ ] rename *src cols* to *tbl cols*
  - [ ] AMobj$load
    - [ ] validate nrow
    - [ ] data types validation - except first load
    - [ ] add metadata id
    - [ ] restatement
    - [ ] append log
  - [ ] AMobj$insert
    - [ ] rbindlist
    - [ ] resetkey
